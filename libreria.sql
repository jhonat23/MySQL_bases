-- CLASE 8: CREAR TABLAS EN UN DB YA CREADO
CREATE TABLE IF NOT EXISTS books (
    -- REGLA OBLIGATORIA: TODA TABLA DEBE TENER UN ID
    book_id INTEGER UNSIGNED PRIMARY KEY AUTO_INCREMENT, --ESTO QUIERE DECIR: CREAR ESQUEMA DE TUPLAS (UNA COLUMNA) LLAMADO book_id CUYA ASIGANCIÓN SEAN ENTEROS POSITIVOS Y E INCREMENTEN AUTOMATICAMENTE
    author_id INTEGER UNSIGNED ,--CREAR COLUMNA DE AUTOR, COMO ESTOY TRAYENDO ESTA COLUMNA DE OTRA TABLA LOS DATOS DEBEN SER EL MISMO TIPO Y OBVIAMENTE EL TAG TAMBIÉN
    title VARCHAR(100) NOT NULL, -- CREAR COLUMNA DE TITULO TIPO TEXTO QUE NO SOBREPASE LOS 100 CARACTERES (STRING) Y NO PUEDE QUEDAR VACIO (NULL)
    year INTEGER UNSIGNED NOT NULL DEFAULT 1900, -- CREAR COLUMNA DE AÑO TIPO ENTERO, NO PUEDE QUEDAR VACIO Y SI NO HAY UN AÑO COLOCAR 1900 POR DEFECTO
    language VARCHAR(2) NOT NULL DEFAULT 'es' COMMENT 'ISO 639-1 Language',--CREAR COLUMNA DE LENGUAJE DE DOS CARACTERES, NO PUEDE QUEDAR VACIO, ESPAÑOL POR DEFECTO Y SE AGREGA UN COMENTARIO INTERNO
    cover_url VARCHAR(500),
    price DOUBLE(6,2) NOT NULL DEFAULT 10.0,--CREAR COLUMNA PRECIO DE TIPO DOUBLE DE 4 DIGITOS ENTEROS Y 2 DECIMALES, 10 POR DEFECTO
    sellable TINYINT(1) DEFAULT 1,--CREAR COLUMNA VENDIBLE DE TIPO BINARIO DE UN BYTE, POR DEFECTO SE ASIGNA 1 COMO VENDIBLE Y 0 COMO NO VENDIBLE
    copies INTEGER NOT NULL DEFAULT 1,
    description TEXT
);

--ARREGLO PARA SUBIR A CONSOLA:
-- CLASE 8: CREAR TABLAS EN UN DB YA CREADO
CREATE TABLE IF NOT EXISTS books (
    book_id INTEGER UNSIGNED PRIMARY KEY AUTO_INCREMENT, 
    author_id INTEGER UNSIGNED,
    title VARCHAR(100) NOT NULL,
    year INTEGER UNSIGNED NOT NULL DEFAULT 1900,
    language VARCHAR(2) NOT NULL DEFAULT 'es' COMMENT 'ISO 639-1 Language',
    cover_url VARCHAR(500),
    price DOUBLE(6,2) NOT NULL DEFAULT 10.0,
    sellable TINYINT(1) DEFAULT 1,
    copies INTEGER NOT NULL DEFAULT 1,
    description TEXT
);

--CLASE 9 CREAR TABLA AUTORES Y LIGARLA A TABLA LIBROS
CREATE TABLE IF NOT EXISTS authors (
    author_id INTEGER UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    nationality VARCHAR(3)
);

--CLASE 10 CREAR TABLA DE CUSTOMER
CREATE TABLE customer(
    customer_id INTEGER UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    'name' VARCHAR(50) NOT NULL, --PARA EVITAR CONFUSIONES CON PALABRAS RESEVADAS COLOCO EL NOMBRE DE LA COLUMNA ENTRE COMILLAS
    email VARCHA(100) NOT NULL UNIQUE, --UNIQUE SE REFIERE A QUE LOS DATOS ALMACENADOS EN ESTA COLUMNA SERÁN ÚNICOS Y NO PODRÁN HABER DOS IGUALES
    birthdate DATETIME,
    gender ENUM('M', 'F', 'ND') NOT NULL, --ENUM INDICA QUE DATOS PUEDEN ESTAR EN ESTA COLUMNA 
    active TINYINT(1) NOT NULL DEFAULT 1, --ESTA COLUMNA ME AYUDA A IDENTIFICAR QUE CLIENTES ESTÁN O NO ACTIVOS O SE DARON DE BAJA
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,-- LA DIFERENCIA ENTRE DATETIME Y TIMESTAMP RADICA EN LA FORMA QUE EN QUE SALE LA INFO Y COMO LA PUEDO UTILIZAR. TIMESTAMP SACA EL FORMATO "yyyy-mm-dd hh:mm:ss" Y ARRANCA DESDE 1970, SIRVE PARA HACER CÁLCULOS. DATETIME SI ES UN DATO ESTÁNDAR DE FECHA. CURRENT_TIMESTAMP ESPECIFICA LA FECHA Y HORA AL MOMENTO DE AGREGAR AL CLIENTE 
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP --ON UPDATE QUIERE DECIR QUE AL MOMENTO DE ACTUALIZAR LOS DATOS SE TOMA NUEVAMEMTE EL TIEMPO AL MOMENTO DE LA ACTUALIZACIÓN DEL CLIENTE
);

--ARREGLO PARA SUBIR A CONSOLA:
--CLASE 10 CREAR TABLA DE CUSTOMER
CREATE TABLE customer(
    customer_id INTEGER UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    birthdate DATETIME,
    gender ENUM('M', 'F', 'ND') NOT NULL,
    active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

--TAREA: CREAR TABLA DE OPERACIONES DE LIBROS
CREATE TABLE IF NOT EXISTS operations (
    operation_id INTEGER UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    book_id INTEGER UNSIGNED,
    customer_id INTEGER UNSIGNED,
    op_type ENUM('LOANED', 'RETURNED', 'SOLD') COMMENT 'IF BOOK IS RETURNED OR SOLD, FINISHED LABEL WILL HAVE 1',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    price DOUBLE(6,2) NOT NULL DEFAULT 10.0,
    finished TINYINT(1) NOT NULL
);

--CLASE 11: INSERTAR
--TRES FORMAS DE HACER INSERT EN LAS TABLAS
--1
INSERT INTO authors(author_id, name, nationality)
VALUES(NULL,'Juan Rulfo','MEX');
--2
INSERT INTO authors(name, nationality)
VALUES('Gabriel García Marquez', 'COL');
--3
INSERT INTO authors
VALUES(NULL,'Juan Gabriel Vasquez','COL');
-- VARIOS DATOS
INSERT INTO authors(name, nationality)
VALUES('Julio Cortázar', 'ARG'),
('Isabel Allende', 'CHI'),
('Octavio Paz', 'MEX'),
('Juan Carlos Onetti', 'URU')
--PUEDO ASIGNAR UN ID
INSERT INTO authors(author_id, name)
VALUES(16,'Pablo Neruda');

--CLASE 12 ON DUPLICATE KEY
--SUBIDA DE DATOS PARA EL EJEMPLO:
INSERT INTO customer(customer_id,name,email,birthdate,gender,active) VALUES (1,'Maria Dolores Gomez','Maria Dolores.95983222J@random.names','1971-06-06','F',1),
(2,'Adrian Fernandez','Adrian.55818851J@random.names','1970-04-09','M',1),
(3,'Maria Luisa Marin','Maria Luisa.83726282A@random.names','1957-07-30','F',1),
(4,'Pedro Sanchez','Pedro.78522059J@random.names','1992-01-31','M',1);
-- QUE PASA SI VUELVO A SUBIR UNO DE ESTOS DATOS:
INSERT INTO customer(name,email,birthdate,gender,active) VALUES('Pedro Sanchez','Pedro.78522059J@random.names','1992-01-31','M',1);
-- SALE ESTE ERROR: ERROR 1062 (23000): Duplicate entry 'Pedro.78522059J@random.names' for key 'email' POR QUE EL DATO EMAIL ES UNIQUE
-- QUE PASA SI CAMBIO EL ESTADO?
INSERT INTO customer(name,email,birthdate,gender,active) VALUES('Pedro Sanchez','Pedro.78522059J@random.names','1992-01-31','M',0)
ON DUPLICATE KEY IGNORE ALL; --IGNORE ALL ES MUY PELIGROSO POR QUE PUEDE OMITIR ERRORES DELICADOS
INSERT INTO customer(name,email,birthdate,gender,active) VALUES('Pedro Sanchez','Pedro.78522059J@random.names','1992-01-31','M',0)
ON DUPLICATE KEY UPDATE active = VALUES(active); -- ESTO QUIERE DECIR QUE ACTUALICE EL ESTADO ACTIVO DE LA TABLA AL QUE LE INDICO EN LA SOLICITUD. CLARAMENTE EL CUSTOMER YA DEBE ESTAR CREADO.

--CLASE 13: QUERIES ANIDADOS
-- INSERSIÓN DE LIBRO, SUPONGAMOS QUE TENEMOS ESTE ARCHIVO EN TEXTO PLANO (.CSV)
-- El laberinto de la soledad, Octavio Paz, 1952
-- Vuelta al laberinto de la soledad, Octavio Paz, 1960
INSERT INTO books(title, author_id)
VALUES('El laberinto de la soledad', 6);
--PERO PUEDO TAMBIÉN HACER UN QUERY DENTRO ESTE QUERY DE LA SIGUIENTE FORMA:
INSERT INTO books(title,author_id,year)
VALUES('Vuelta al laberinto de la soledad', (SELECT author_id FROM authors WHERE name = 'Octavio Paz' LIMIT 1), 1960); --DESDE EL SELECT SE ESTABLECE EL SUBQUERY PARA TRAER DESDE OTRA TABLA EL VALOR RELACIONADO AL REGISTRO, ESTO ES MUY PODEROSO PERO HAY QUE TENER EN CUENTA QUE PUEDE AUMENTAR EL PODER DE PROCESAMIENTO

--CLASE 15: COMANDO SELECT
SELECT name, email, gender FROM clients WHERE gender='F';
SELECT birthdate FROM clients;
SELECT year(birthdate) FROM clients;--LE PUEDO CARGAR FUNCIONES AL SELECT, POR EJEMPLO YEAR QUE SEPARA EL AÑO DEL DATO TIPO DATETIME
SELECT YEAR(NOW()) - YEAR(birthdate) FROM clients; --PUEDO CREAR "TABLAS DINÁMICAS" CON FUNCIONES Y CÁLCULOS
SELECT name, email AS correo, YEAR(NOW()) - YEAR(birthdate) AS edad, gender FROM clients WHERE gender = 'F' AND name LIKE '%Lop%';--MÁS: "AS" SIRVE PARA CAMBIAR EL NOMBRE DE UNA COLUMNA CUANDO SE CONSULTA, "AND" SIRVE COMO CONDICIONAL ADICIONAL AL WHERE (SEGURAMENTE ESTA "OR") Y "LIKE" ACTUA COMO UN BUSCADOR

--CLASE 16: COMANDO JOIN
SELECT b.book_id, a.name, a.author_id, b.title FROM books AS b JOIN authors AS a ON a.author_id = b.author_id WHERE a.author_id BETWEEN 1 AND 5;--ACÁ SELECCIONO LAS COLUMNAS DEL PIVOTE Y LAS DE LA TABLA QUE REQUIERO UNIR DESDE EL PIVOTE DONDE HAY UNIÓN ENTRE LAS COLUMNAS "AUTHOR" DE LAS DOS TABLAS SELECCIONADAS
--JUNTAR VARIAS TABLAS A PARTIR DEL PIVOTE DE TRANSACTIONS. AL PARECER LOS PIVOTES SE DEFINEN DESDE LA TABLA QUE SE QUIERE MOSTRAR DIRECTAMENTE
SELECT c.name, b.title, t.type, t.finished
FROM transactions AS t
JOIN books as b ON b.book_id = t.book_id
JOIN clients AS c ON c.client_id = t.client_id;--IMPORTANTE: EL HECHO DE HACER JOIN IMPLICA QUE LOS VALORES A CRUZAR DEBEN COINCIDIR, A PARTIR DE AHÍ PUEDO TRAER DE TODAS LAS TABLAS UNIDAS TODAS LAS COLUMNAS DE TALES TABLAS
-- UN QUERY CON MÁS DETALLE...
SELECT c.name, b.title, a.name, t.type, t.finished
FROM transactions AS t
JOIN books as b ON b.book_id = t.book_id
JOIN clients AS c ON c.client_id = t.client_id
JOIN authors AS a ON b.author_id = a.author_id--IMPORTANTE: PUEDO HACER JOINS DESDE UNA TABLA QUE YA HAYA SIDO INVOCADA PREVIAMENTE PARA EL JOIN PRINICPAL
WHERE c.gender = 'M' AND t.type IN ('sell', 'lend');--EL CONDICIONAL IN ESPECIFICA SOBRE LOS DATOS DE LA COLUMNA CUALES DEBO DE TRAER SEGÚN LOS VALORES INDICADOS

--CLASE 17: LEFT JOIN
--OTRA FORMA DE HACER JOIN:
SELECT b.title, a.name
FROM authors AS a, books AS b
WHERE a.author_id = b.author_id--AQUÍ ES DONDE REALMENTE OCURRE EL JOIN (INNER JOIN), EL MÉTODO ANTERIOR SE DA MÁS POR FACILIDAD DE LECTURA
LIMIT 10;

SELECT a.author_id, a.name, a.nationality, b.title
FROM authors AS a
JOIN books as b ON a.author_id = b.author_id
WHERE a.author_id BETWEEN 1 AND 5
ORDER BY a.author_id; -- ESTE COMANDO ME AYUDA A DAR UN ORDEN ESPECÍFICO AL QUERY

--AL APLICAR LEFT JOIN HAGO QUE LA TABLA PIVOTE TOME LA TABLA REFERENCIADA Y TRAIGA TODO DESDE LA "DERECHA" DESPUÉS DE LA COLUMNA QUE CRUZO. ESTO HACE QUE DATOS QUE NO SALEN EN EL INNER JOIN POR SER NULL SALGAN DESPUÉS DEL JOIN
SELECT a.author_id, a.name, a.nationality, b.title
FROM authors AS a
LEFT JOIN books as b ON a.author_id = b.author_id
WHERE a.author_id BETWEEN 1 AND 5
ORDER BY a.author_id;

--FUNCIONES EN COLUMNAS:
SELECT a.author_id, a.name, a.nationality, COUNT(B.book_id)
FROM authors AS a
LEFT JOIN books as b ON a.author_id = b.author_id
WHERE a.author_id BETWEEN 1 AND 5
GROUP BY A.author_id
ORDER BY a.author_id;
--LA FUNCIÓN COUNT ME AYUDA A CONTAR CUANTAS VECES SALE UN REGISTRO DE UNA COLUMNA LIGADO A OTRO TIPO DE REGISTRO. EN ESTA CASO ES PARA SABER CUANTOS LIBROS TIENE CADA AUTOR. ES OBLIGATORIO SELECCIONAR SOBRE CUÁL COLUMNA DEBO AGRUPAR.

--CLASE 19:
--RESOLVER LAS SIGUIENTES DUDAS A TRAVÉS DE QUERIES:
--¿QUÉ NACIONALIDADES HAY?
SELECT nationality
FROM authors
GROUP BY nationality;
-- RESPUESTA PROFESOR:
SELECT DISTINCT nationality 
FROM authors
GROUP BY nationality;
-- DISTINCT SEPARA DE UNA VEZ

--¿CUANTOS ESCRITORES HAY DE CADA NACIONALIDAD?
SELECT nationality, COUNT(nationality), SUM(IF(nationality IS NULL, 1,'N/A')) 
FROM authors
GROUP BY nationality;
--SE GENERA UNA COLUMNA CON EL CONTEO DE NULL PERO DEJANDO LAS OTRAS NACIONALIDADES EN CERO
--RESPUESTA DEL PROFESOR:
SELECT nationality, COUNT(author_id) AS c_authors
FROM authors
WHERE nationality IS NOT NULL
AND nationality NOT IN('RUS', 'AUT')
GROUP BY nationality
ORDER BY c_authors DESC, nationality ASC;--PRIORIDAD DE ORDEN

--¿CUANTOS LIBROS HAY DE CADA NACIONALIDAD?
SELECT a.nationality, COUNT(b.book_id)
FROM books AS b 
JOIN authors AS a ON b.author_id = a.author_id
WHERE nationality IS NOT NULL
GROUP BY nationality;
--RESPUESTA DEL PROFESOR:


--¿CUAL ES EL PROMEDIO/DESVIACIÓN STANDARD DEL PRECIO DE LOS LIBROS?
SELECT AVG(price) AS medium_price, STDDEV(price) AS standard_dev
FROM books;
-- IGUAL A RESPUESTA DEL PROFESOR

--IDEM, PERO POR NACIONALIDAD (PROMEDIO Y DEV STANDARD DEL PRECIO POR PAÍS)
SELECT a.nationality, AVG(b.price) AS medium_price_nation, STD(b.price) AS standard_dev_nation
FROM books AS b 
JOIN authors AS a ON b.author_id = a.author_id
GROUP BY nationality;
--RESPUESTA DEL PROFESOR:
SELECT a.nationality, COUNT(book_id) AS libros, AVG(b.price) AS medium_price_nation, STD(b.price) AS standard_dev_nation
FROM books AS b 
JOIN authors AS a ON b.author_id = a.author_id
GROUP BY nationality
ORDER BY libros DESC;

--¿CUAL ES EL PRECIO MÁXIMO DE UN LIBRO
SELECT a.nationality, MAX(b.price) AS max_price, MIN(b.price) AS min_price
FROM books AS b 
JOIN authors AS a ON b.author_id = a.author_id
GROUP BY nationality;
--IGUAL RESPUESTA DEL PROFESOR


--¿COMO QUEDAIA EL REPORTE DE PRESTAMOS?
SELECT type, COUNT(type), finished
FROM transactions
GROUP BY type;
--RESPUESTA DE PROFESOR:
SELECT c.name AS client_name, t.type, b.title, CONCAT(a.name, ' (', a.nationality,')') AS autor, FLOOR((TO_DAYS(NOW()) - TO_DAYS(c.birthdate))/365) AS edad
FROM transactions as t
LEFT JOIN clients AS c ON c.client_id = t.client_id
LEFT JOIN books AS b ON b.book_id = t.book_id
LEFT JOIN authors AS a ON a.author_id = b.author_id;
--CONCAT ME PERMITE UNIR VARIAS COLUMNAS EN UNA SOLA DURANTE EL SELECT, FLOOR ME AYUDA A REDONDEAR NUMEROS, TO_DAYS ME ENTREGA LOS DÍAS QUE HAN TRANSCURRIDO DESDE EL INICIO DE LOS TIEMPOS HASTA LA FECHA QUE ESPECIFIQUE

--AGREGO PRECIOS A LA TABLA BOOKS:
UPDATE books
SET price = FLOOR(RAND()*(35-1+1))+1
WHERE book_id BETWEEN 1 AND 198;
--FUNCION RAND DEVUELVE NÚMEROS ALETAROTIOS, UPDATE ES PARA ACTUALIZAR REGISTROS

--CLASE 21: UPDATE Y DELETE
--QUIERO BORRAR UN DATO ESPECÍFICO
SELECT * FROM authors ORDER BY RAND() LIMIT 10; --CON ESTO SELECCIONO 10 DATOS RANDOM DE LA TABLA (SOLO PARA FINES DE CLASE)
--DELETE
DELETE FROM authors
WHERE author_id = 161 LIMIT 1; --BORRA EL REGISTRO PUNTUAL, SE RECOMIENDA PONER LIMIT PARA EVITAR BORRAR DE MÁS
--UPDATE
UPDATE clients
SET active = 0
WHERE client_id = 80
LIMIT 1;

UPDATE clients
SET email = 'javier@gmail.com'
WHERE client_id = 7
LIMIT 1;

--CLASE 22: "SUPER QUERYS"
SELECT COUNT(book_id), SUM(IF(year < 1950, 1, 0)) AS '<1950', SUM(IF(year < 1950, 0, 1)) AS '>1950'
FROM books;

SELECT COUNT(book_id), 
SUM(IF(year < 1950, 1, 0)) AS '<1950', 
SUM(IF(year >=1950 AND year <1990, 1, 0)) AS '<1990', 
SUM(IF(year >=1990 AND year <2000, 1, 0)) AS '<2000',
SUM(IF(year >=2000 , 1, 0)) AS '<hoy'
FROM books;--LOS CONDICIONALES IF AYUDAN A CREAR MATRICES O TABLAS MUCHO MÁS DINAMICAS

SELECT a.nationality, COUNT(b.book_id), 
SUM(IF(year < 1950, 1, 0)) AS '<1950', 
SUM(IF(year >=1950 AND year <1990, 1, 0)) AS '<1990', 
SUM(IF(year >=1990 AND year <2000, 1, 0)) AS '<2000',
SUM(IF(year >=2000 , 1, 0)) AS '<hoy'
FROM books AS b
JOIN authors AS a ON a.author_id = b.author_id
WHERE a.nationality IS NOT NULL
GROUP BY a.nationality;

--CLASE 23: MYSQLDUMP'
--COMANDO ALTER: PARA AGREGAR COLUMNAS A UN TABLA YA CREADA
ALTER TABLE authors ADD COLUMN birthyear INTEGER DEFAULT 1930 AFTER name;
--PUEDO MODIFICAR TAMBIÉN UNA COLUMNA EXISTENTE
ALTER TABLE authors MODIFY COLUMN birthyear YEAR DEFAULT 1920;
--PUEDO ELIMINAR UNA COLUMNA
ALTER TABLE authors DROP COLUMN birthyear;
--MYSQLDUMP ES UNA HERRAMIENTA EXTERNA A MYSQL
